* Bubble冒泡排序： 数组内第i个和第i+1个进行两两比较,逐步将大的丢到后面
* select选择排序： 在内循环中得到最小的数的下标 循环结束时 将内循环得到的最小数和外循环i交换
* InserSort插入排序: 将无序序列插入到有序序列中 
    + 如果序列是基本有序,插入效率高
        + 基本有序 小的基本在左边 打的基本在右边 
    + 数据序列比较少,插入效率高
* ShellSort希尔排序：分组插入排序
    + 通过增量进行分组 增量公式 increasement / 3 + 1
    + 希尔排序又名减少增量排序
* FastSort快速排序
    + 分治法 + 挖坑填树
    + 分治法：大问题分解成一个一个的小问题，对小问题求解，使得大问题得以解决
        + 定义一个基准数 底数为0的数
        + 定义一个头指针 和 尾指针
        + 0的位置已经作为基准数了，所有为空 头指针是空所以堵塞
            + 所以从尾指针从右到左开始找小于基准元素的数
            + 找到以后放到头指针处,然后此时尾指针为空
            + 因为头指针不为空了，所以从左到右开始找大于基准树的数
            + 以此往复
        + 当头指针和尾指针重合以后把基准树放入重合的部分
        + 然后左边和右边都指向这个
    + 所以使用递归
* 归并排序：
    + 基本思想：将两个有序序列合并成一个有序序列
    + 拿到一个无序序列。取中间值拆，直到拆成一个有序数列
* 堆排序
    + 堆：
        + 大顶堆 完全二叉树 但从根节点往下越来越小 升序排列
        + 小顶堆 完全二叉树 但从根节点往下越来越大 降序排列
    + 给了我们一个数组，就相当于给了我们一个完全二叉树,
    他还不满足堆的条件
        + 1 通过调整堆 初始化堆 从下往上调整
            + 数组的个数除以二正好是最后一个非叶子节点
        + 2 从上往下调整 